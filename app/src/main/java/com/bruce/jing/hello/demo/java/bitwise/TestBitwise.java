package com.bruce.jing.hello.demo.java.bitwise;

import android.util.Log;

import com.bruce.jing.hello.demo.util.log.JLogUtil;

/**
 * -------------------------------------
 * 作者：bruce jing
 * -------------------------------------
 * 时间：2018/8/28 下午9:14
 * -------------------------------------
 * 描述：
 * -------------------------------------
 * 备注：
 * -------------------------------------
 */
public class TestBitwise {

    /**
     *
     *
     *
     1、原码
     正数 0 XXXXXXX
     负数 1 XXXXXXX
     2、反码
     正数 0 XXXXXXX（同原码）
     负数 1 XXXXXXX（原码取反）
     3、补码
     正数 0 XXXXXXX（同原码）
     负数 1 XXXXXXX（原码取反+1）




     在计算机数据都是以补码的方式存储的，我认为原因主要以下两个(自我理解)

     　　　　优点：

     　　　　1.避免了0的编码有两个

     　　　　2.符号位和有效值位可以一起处理，减法通过加法就可以实现，即简化了计算机的结构设计也提高了运算速度。

     　　　　补：计算机的加减运算都是通过加法实现的，乘除运算都是通过乘法实现的(当然有的计算机有乘法器，有的计算　　　　　　机无乘法器，乘法也是由加法器实现的)

     */



    /**
     *  与（&）、或（|）、非（~）、异或（^）
     *
     */

    /**
     *
     * <<      :     左移运算符，num << 1,相当于num乘以2
     * >>      :     右移运算符，num >> 1,相当于num除以2
     * >>>    :     无符号右移，忽略符号位，空位都以0补齐
     *
     */


    /**
     *
     运算规则：如果位为0，结果是1，如果位为1，结果是0.

     比如：~37

     在Java中，所有数据的表示方法都是以补码的形式表示，如果没有特殊说明，Java中的数据类型默认是int,int数据类型的长度是8位，一位是四个字节，就是32字节，32bit.

     8转为二进制是100101.

     补码后为： 00000000 00000000 00000000 00100101

     取反为：    11111111 11111111 11111111 11011010

     因为高位是1，所以原码为负数，负数的补码是其绝对值的原码取反，末尾再加1。

     因此，我们可将这个二进制数的补码进行还原： 首先，末尾减1得反码：11111111 11111111 11111111 11011001 其次，将各位取反得原码：

     00000000 00000000 00000000 00100110，此时二进制转原码为38

     所以~37 = -38.
     */

    public void testBitwise(){
        //~
        int i = 37;
        JLogUtil.d(TestBitwise.class.getName(),Integer.toBinaryString(i));//00000000 00000000 00000000 00100101
        JLogUtil.d(TestBitwise.class.getName(),Integer.toBinaryString(~i));//11111111 11111111 11111111 11011010

    }
}
